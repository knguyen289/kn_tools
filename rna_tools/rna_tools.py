import matplotlib.pyplot as plt
import seaborn as sns 
import numpy as np 
import pandas as pd 
import copy

def am_gen(data_df,b1,b2):
    """Generates the geometric mean of the proportion of the window exons take up for a given dataframe (which should represent one plot)
    
    Parameters:
        data_df: (Pandas DataFrame) The DataFrame created using basic_tools text_to_df for the UCSC data, has a 'name2' column
    """
    total = 0
    ex_count = 0
    
    for index,row in data_df.iterrows():
        s = row.get_value('exonStarts')[:-1].split(',')
        s = sorted(map(int,s))
        e = row.get_value('exonEnds')[:-1].split(',')
        e = sorted(map(int,e))
        
        for i in range(len(s)):
            exlen = e[i] - s[i]
            if exlen > 0:
                total += float(abs(e[i]-s[i]))/(abs(b2-b1))
                ex_count += 1
                
    return float(total)/ex_count

def scale(df):
    """Takes in a dataframe of ucsc info to be plotted, and creates the plottable segments without augmentation, returns the plottable dataframe

    Parameters:
        df: (Pandas DataFrame) The DataFrame created by the filter on the UCSC data_df, has one bin, one strand direction, and one rna attributed to it"""
    df = copy.deepcopy(df)
    segs = []
    
    if not 's1' in list(df.columns):
        df.insert(len(df.columns),'s1',0)
    if not 's2' in list(df.columns):
        df.insert(len(df.columns),'s2',0)
    if not 's3' in list(df.columns):
        df.insert(len(df.columns),'s3',0)
    for index,row in df.iterrows():
        s = map(int,list(row.get_value('exonStarts')[:-1].split(',')))
        e = map(int,list(row.get_value('exonEnds')[:-1].split(',')))
        tx = map(int,[row.get_value('txStart'),row.get_value('txEnd')])
        cds = map(int,[row.get_value('cdsStart'),row.get_value('cdsEnd')])
        
        nodes = sorted(s+e)
        
        seg1 = sorted(list(set([tx[0]] + [pt for pt in nodes if pt <= cds[0]] + [cds[0]])))
        seg2 = sorted(list(set([cds[0]] + [pt for pt in nodes if pt >= cds[0] and pt <= cds[1]] + [cds[1]])))
        seg3 = sorted(list(set([cds[1]] + [pt for pt in nodes if pt >= cds[1]] + [tx[1]])))
        
        df.loc[index,'s1'] = ','.join(map(str,seg1))
        df.loc[index,'s2'] = ','.join(map(str,seg2))
        df.loc[index,'s3'] = ','.join(map(str,seg3))
    return df

def augment(df,am):
    """Takes in a dataframe of ucsc info to be plotted, and creates the plottable segments with augmentation, returns the plottable dataframe

    Parameters:
        df: (Pandas DataFrame) The DataFrame created by the filter on the UCSC data_df, has one bin, one strand direction, and one rna attributed to it
        am: (float) The arithmetic mean generated by am_gen function, must be below 0.02 to be useful, used as the index to scale up exons"""
    df = copy.deepcopy(df)
    segs = []
    
    if not 's1' in list(df.columns):
        df.insert(len(df.columns),'s1',0)
    if not 's2' in list(df.columns):
        df.insert(len(df.columns),'s2',0)
    if not 's3' in list(df.columns):
        df.insert(len(df.columns),'s3',0)
    for index,row in df.iterrows():
        s = map(int,list(row.get_value('exonStarts')[:-1].split(',')))
        e = map(int,list(row.get_value('exonEnds')[:-1].split(',')))
        tx = map(int,[row.get_value('txStart'),row.get_value('txEnd')])
        cds = map(int,[row.get_value('cdsStart'),row.get_value('cdsEnd')])
        
        exons = []
        for i in range(len(s)):
            exons.append([s[i],e[i]])
        #Take the median of each exon and length
        
        scale = 0.02/am
        aug_ex = []
        aug_s = []
        aug_e = []
        for exon in exons:
            #Scaling up the exons
            s_i = exon[0]
            e_i = exon[1]
            
            if len(aug_ex) > 0 and len(aug_ex) != len(exons)-1:
                m = (s_i + e_i)/2.0
                s_f = m - scale*(e_i - m)
                e_f = m + scale*(e_i - m)
            elif len(aug_ex) == 0 and len(aug_ex) != len(exons)-1:
                l = e_i - s_i
                s_f = e_i - scale*l
                e_f = e_i
            elif len(aug_ex) != 0 and len(aug_ex) == len(exons)-1:
                l = e_i - s_i
                e_f = s_i + scale*l
                s_f = s_i
            else:
                m = (s_i + e_i)/2.0
                s_f = m - scale*(e_i - m)
                e_f = m + scale*(e_i - m)
                
            s_f = int(s_f - 0.5)
            e_f = int(e_f + 0.5)
            #Making sure the tx starts/ends are adjusted if they have also been augmented
            if s_f < tx[0]:
                tx[0] = s_f
            if s_f < cds[0]:
                m_i = (s_i + e_i)/2.0
                m_f = (s_f + e_f)/2.0
                cds[0] = m_f - scale*(m_i - cds[0])
            if e_f > tx[1]:
                tx[1] = e_f
            if e_f > cds[1]:
                m_i = (s_i + e_i)/2.0
                m_f = (s_f + e_f)/2.0
                cds[1] = m_f + scale*(m_i - cds[1])
            aug_ex.append([s_f,e_f])
            aug_s.append(s_f)
            aug_e.append(e_f)
            
        aug_nodes = sorted(aug_s+aug_e)
        seg1 = sorted(list(set([tx[0]] + [pt for pt in aug_nodes if pt <= cds[0]] + [cds[0]])))
        seg2 = sorted(list(set([cds[0]] + [pt for pt in aug_nodes if pt >= cds[0] and pt <= cds[1]] + [cds[1]])))
        seg3 = sorted(list(set([cds[1]] + [pt for pt in aug_nodes if pt >= cds[1]] + [tx[1]])))
        
        #rewrite info in dataframe to augmented data
        df.loc[index,'exonStarts'] = ','.join(map(str,sorted(aug_s))) + ','
        df.loc[index,'exonEnds'] = ','.join(map(str,sorted(aug_e))) + ','
        df.loc[index,'txStart'] = tx[0]
        df.loc[index,'txEnd'] = tx[1]
        df.loc[index,'cdsStart'] = cds[0]
        df.loc[index,'cdsEnd'] = cds[1]
        
        #add in the segment data
        df.loc[index,'s1'] = ','.join(map(str,seg1))
        df.loc[index,'s2'] = ','.join(map(str,seg2))
        df.loc[index,'s3'] = ','.join(map(str,seg3))
    return df

def plot_seg(ax,r,seg,exons,c,w):
    """Plots the exons on a single segment of the rna, each rna has 3 segments: 1 is before the cdsStart, 2 is between cdsStart and cdsEnd, 3 is past cdsEnd

    Parameters:
        ax: (Matplotlib Axis) The axis to plot the seg onto
        r: (int) The y value to plot the seg onto
        seg: (list) The list of exon start and ends to plot
        exons: (list of lists) The list of exons for ex_i, the list has an element [s_i,e_i]
        c: (str) Valid matplotlib color to plot, for seg 2's it should be Crimson, for seg 1 and 3's it should be #8c0d26
        w: (float) The width of the line, for seg 2's it should be 20, for seg 1 and 3's it should be 10"""
    for i in range(len(seg)-1):
        for exon in exons:
            if seg[i] >= exon[0] and seg[i+1] <= exon[1]:
                ax.hlines(r,seg[i],seg[i+1],colors=c,linewidth=w)
                pass

def ucsc_plot(rna,data,fname=None,override=False,excd='Crimson',extx='#8c0d26',incd='#ffbab3',intx='MistyRose'):
    """Produces all the plot for the UCSC data of a single rna, separates plots by bin and strand, augments if am is below 0.02

    Parameters:
        rna: (str) The RNA name, must be one from the 'name2' column in the UCSC dataframe
        data: (str) The UCSC DataFrame created from the text_to_df function
        fname: (str) If file output to pdf, put a special fname for this rna, separate plots will be produced and labeled with corresponding bin and strand [Optional]
        override: (boolean) Set to True if you want the unscaled version even if it is under the 0.02 threshold [Optional]
        excd: (str) Matplotlib compatible color for exons in coding region [Optional]
        extx: (str) Matplotlib compatible color for exons out of coding region [Optional]
        incd: (str) Matplotlib compatible color for introns in coding region [Optional]
        intx: (str) Matplotlib compatible color for introns out of coding region [Optional]"""

    str_aug = ''
    sns.set_style('whitegrid')
    temp_df = copy.deepcopy(data)
    temp_df = temp_df[temp_df['name2'] == rna]
    
    strands = list(set(temp_df['strand']))
    for strand in strands:
        strand_df = temp_df[temp_df['strand'] == strand]
        bins = list(set(strand_df['#bin']))
        for b in bins:
            bin_df = strand_df[strand_df['#bin'] == b]
            try:
                fig,ax = plt.subplots()

                b1 = min(map(int,list(bin_df['txStart']))) - 100
                b2 = max(map(int,list(bin_df['txEnd']))) + 100

                am = am_gen(bin_df,b1,b2)

                if am > 0.02 or override:
                    plot_df = scale(bin_df)
                else:
                    plot_df = augment(bin_df,am)
                    str_aug = 'augmented'
                    b1 = min(map(int,list(plot_df['txStart']))) - 100
                    b2 = max(map(int,list(plot_df['txEnd']))) + 100
                r = 0
                for index,row in plot_df.iterrows():
                    s = map(float,list(row.get_value('exonStarts')[:-1].split(',')))
                    e = map(float,list(row.get_value('exonEnds')[:-1].split(',')))
                    tx = map(float,[row.get_value('txStart'),row.get_value('txEnd')])
                    cds = map(float,[row.get_value('cdsStart'),row.get_value('cdsEnd')])
                    nodes = sorted(s+e)
                    exons = []
                    for i in range(len(s)):
                        exons.append([s[i],e[i]])

                    seg1 = map(float,row.get_value('s1').split(','))
                    seg2 = map(float,row.get_value('s2').split(','))
                    seg3 = map(float,row.get_value('s3').split(','))

                    ax.hlines(r,tx[0],tx[1],colors=intx,linewidth=10)
                    ax.hlines(r,cds[0],cds[1],colors=incd,linewidth=10)
                    plot_seg(ax,r,seg1,exons,extx,10)
                    plot_seg(ax,r,seg3,exons,extx,10)

                    plot_seg(ax,r,seg2,exons,excd,20)
                    r += 1

                if row.get_value('strand') == '+':
                    lb = b1 - 100
                    rb = b2 + 100
                else:
                    lb = b2 + 100
                    rb = b1 - 100

                ax.set_xlim([lb,rb]) 
                ax.get_xaxis().set_visible(False)
                ax.get_yaxis().set_visible(False)
                ax.set_ylim([-1,len(bin_df.index)])
                ax.set_title(rna + ' ' + str_aug + ' bin ' + str(b) + ' (' + str(strand) + ') window: ' + 
                             str(b2-b1),fontsize=20)
                fig.set_size_inches(12,(len(bin_df.index)*0.5+4))
                plt.tight_layout()
                if fname == None:
                    plt.show()
                    plt.close()
                else:
                    plt.savefig(fname + str(strand) + str(b) + str_aug + '.pdf')
            except:
                plt.close()
                print 'Plot could not be produced'
    plt.close()